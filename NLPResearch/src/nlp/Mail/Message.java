package nlp.Mail;
//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2011.03.04 at 03:38:39 PM EST 
//




import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.regex.Pattern;

import javax.mail.internet.MailDateFormat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import java.util.regex.*;

/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element ref="{}thread_id"/>
 *         &lt;element ref="{}depth"/>
 *         &lt;element ref="{}type"/>
 *         &lt;element ref="{}message_id"/>
 *         &lt;choice maxOccurs="unbounded" minOccurs="0">
 *           &lt;element ref="{}from"/>
 *           &lt;element ref="{}to"/>
 *         &lt;/choice>
 *         &lt;element ref="{}parent_id"/>
 *         &lt;element ref="{}subject"/>
 *         &lt;element ref="{}date_time"/>
 *         &lt;element ref="{}content"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "threadId",
    "depth",
    "type",
    "messageId",
    "fromOrTo",
    "parentId",
    "subject",
    "dateTime",
    "content"
})
@XmlRootElement(name = "message")
public class Message {

    @XmlElement(name = "thread_id", required = true)
    protected BigInteger threadId;
    @XmlElement(required = true)
    protected BigInteger depth;
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "NCName")
    protected String type;
    @XmlElement(name = "message_id", required = true)
    protected BigInteger messageId;
    @XmlElements({
        @XmlElement(name = "to", type = To.class),
        @XmlElement(name = "from", type = From.class)
    })
    protected List<Object> fromOrTo;
    @XmlElement(name = "parent_id", required = true)
    protected String parentId;
    @XmlElement(required = true)
    protected String subject;
    @XmlElement(name = "date_time", required = true)
    protected String dateTime;
    @XmlElement(required = true)
    protected String content;

    /**
     * Gets the value of the threadId property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getThreadId() {
        return threadId;
    }

    /**
     * Sets the value of the threadId property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setThreadId(BigInteger value) {
        this.threadId = value;
    }

    /**
     * Gets the value of the depth property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getDepth() {
        return depth;
    }

    /**
     * Sets the value of the depth property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setDepth(BigInteger value) {
        this.depth = value;
    }

    /**
     * Gets the value of the type property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getType() {
        return type;
    }

    /**
     * Sets the value of the type property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setType(String value) {
        this.type = value;
    }

    /**
     * Gets the value of the messageId property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getMessageId() {
        return messageId;
    }

    /**
     * Sets the value of the messageId property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setMessageId(BigInteger value) {
        this.messageId = value;
    }

    /**
     * Gets the value of the fromOrTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fromOrTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFromOrTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link To }
     * {@link From }
     * 
     * 
     */
    public List<Object> getFromOrTo() {
        if (fromOrTo == null) {
            fromOrTo = new ArrayList<Object>();
        }
        return this.fromOrTo;
    }

    /**
     * Gets the value of the parentId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getParentId() {
        return parentId;
    }

    /**
     * Sets the value of the parentId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setParentId(String value) {
        this.parentId = value;
    }

    /**
     * Gets the value of the subject property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSubject() {
        return subject;
    }

    /**
     * Sets the value of the subject property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSubject(String value) {
        this.subject = value;
    }

    /**
     * Gets the value of the dateTime property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDateTime() {
        return dateTime;
    }

    /**
     * Sets the value of the dateTime property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDateTime(String value) {
        this.dateTime = value;
    }

    /**
     * Gets the value of the content property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getContent() {
        return content;
    }

    /**
     * Sets the value of the content property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setContent(String value) {
        this.content = value;
    }
    
    /*******************************
     * HELPER METHODS
     * ******************************/
    @XmlTransient private String fromString;
    public String getFrom()
    {
    	if(fromString == null)
    	{
    		for(Object o : getFromOrTo())
    			if(o.getClass() == From.class){
    				fromString = ((From)o).getAddress();
    				return ((From)o).getAddress();
    			}
    	}
    	return fromString;
	}
         
    public long getDate()
    {
		SimpleDateFormat xmlFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		//static final SimpleDateFormat timed = new SimpleDateFormat("HH:mm:ss");
		Date d = null;
		try {
			d = xmlFormat.parse(getDateTime());
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}   
		return d.getTime();
    }

	public List<To> getTo() {
		// TODO Auto-generated method stub
		List<To> tos = new ArrayList<To>();
		if(fromOrTo != null)
		{
			for(Object o: fromOrTo)
			{
				if(o.getClass() == To.class)
					tos.add((To)o);
			}
		}
		return tos;
	}
    public String getMD5Sum(To receiver)
    {
    	String temp = getDate() + receiver.getAddress() + getSubject() + getFrom();
		return md5sum(temp.getBytes());
    }
	 /**
	    * method to return the md5sum
	    */ 
	    private final String md5sum(byte[] inputtext) {
	        try {
	            // get Instance from Java Security Classes
	            final MessageDigest md5 = MessageDigest.getInstance("MD5");

	            StringBuffer sb = new StringBuffer();

	            byte [] md5rslt = md5.digest(inputtext);

	            for (int i = 0; i < md5rslt.length; i++) {
	                if ((0xff & md5rslt[i]) < 16) {
	                    // add leading zero if value is a single digit
	                    sb.append("0");
	                }
	                sb.append(Integer.toHexString((0xff & md5rslt[i])));
	            }
	           
	            return sb.toString();
	        } catch (NoSuchAlgorithmException ex) {
	            System.err.println(ex);
	            return null;
	        }
	    }
	    
	    @XmlTransient private String id;
	    
	    public String getId()
	    {
	    	return id;
	    }
	    
	    public void setId(String id)
	    {
	    	this.id = id;
	    }
}


